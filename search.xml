<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>入门Sql:Normal Form(范式)</title>
      <link href="/2018/05/14/%E5%85%A5%E9%97%A8Sql-Normal-Form-%E8%8C%83%E5%BC%8F/"/>
      <url>/2018/05/14/%E5%85%A5%E9%97%A8Sql-Normal-Form-%E8%8C%83%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>学校的数据库书关于范式的定义有些杂乱，用户体验不佳。因此，博主从墙外搬了几块砖头进来，以此体验原滋原味的Normal Form</p><h3 id="First-Normal-Form"><a href="#First-Normal-Form" class="headerlink" title="First Normal Form"></a>First Normal Form</h3><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>A database is in first normal form if it satisfies the following conditions:</p><ul><li>Contains only atomic values</li><li>There are no repeating groups</li></ul><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h3><p>//TODO:</p><p><img src="http://hlx-blog.oss-cn-beijing.aliyuncs.com/18-5-14/77459532.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> Sql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 总结 </tag>
            
            <tag> Normal Form </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>入门Java:Bounded Wildcard Type(有限制通配符类型)</title>
      <link href="/2018/05/13/%E5%85%A5%E9%97%A8Java-Bounded-Wildcard-Type-%E6%9C%89%E9%99%90%E5%88%B6%E9%80%9A%E9%85%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/05/13/%E5%85%A5%E9%97%A8Java-Bounded-Wildcard-Type-%E6%9C%89%E9%99%90%E5%88%B6%E9%80%9A%E9%85%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Bounded Wildcard Type 相对于 UnBounded Wildcard Type 多了一个对于类型参数的限制，即提供了一种有限制的”灵活”。门下有两个徒弟，一个名为Upper Bounded Wildcards(上层限制通配符)，而另一个名为Lower Bounded Wildcards(下层限制通配符)</p><ul><li>Upper Bounded Wildcards 上层限制通配符，即限制了？的最高父类级别。用法：<code>? extends A</code>，则说明parameter type(类型参数)只能为A的子类型或者A本身</li><li>Lower Bounded Wildcards 下层限制通配符，与楼上的相反，即限制了？的最低子类级别。用法：<code>? super A</code>，则说明parameter type只能为A的父类型或者A本身</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h3 id="0-Start"><a href="#0-Start" class="headerlink" title="0.Start"></a>0.Start</h3><p>某些情况下，我们需要编写关于泛型的方法(例如集合)。例如，一个方法的参数是List&lt;Number&gt;，但是该方法的灵活度不高，由于泛型不支持<strong>子类型</strong>。因此，我们只能传入List&lt;Number&gt;对象，而如果使用有限制通配符类型，则可以传入List&lt;Integer&gt;等对象，只要参数类型为Number的子类型即可。  </p><p>至于为什么不选择无限制通配符类型：</p><ul><li>相当于绕过泛型检查，未知的类型使得编译器无法在编译期间进行类型的检查，类型不安全</li></ul><p>关于<strong>子类型</strong>:<br>A是B的子类型，但List&lt;A&gt;不是List&lt;B&gt;的子类型，则说明泛型不支持<strong>子类型</strong></p><h4 id="1-Upper-Bounded-Wildcards"><a href="#1-Upper-Bounded-Wildcards" class="headerlink" title="1.Upper Bounded Wildcards"></a>1.Upper Bounded Wildcards</h4><p>编写关于读取泛型中的数据的方法(查询…)<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line"></span><br><span class="line">    public static void read(List&lt;? extends Number&gt; numbers) &#123;</span><br><span class="line">        for (Number number : numbers) &#123;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3);</span><br><span class="line">        List&lt;Double&gt; doubleList = Arrays.asList(1.2, 1.3);</span><br><span class="line">        read(integerList);</span><br><span class="line">        read(doubleList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1.2</span><br><span class="line">1.3</span><br></pre></td></tr></table></figure></p><p>由于上层限制通配符类型List&lt;? extends Number&gt;支持<strong>子类型</strong>，可传入类型参数为Number或者Number子类型（如Integer，Double,Float）的泛型<br>通过以上方法，则可以遍历参数类型为Number或Number子类型的集合</p><p>选择extends(或者为什么类型参数一定要是”A”的子类型)的思考：</p><p>首先变量只能指向类型为该变量类型的子类型或者相同类型的对象，emmmmm有点复杂，举个栗子：<br>假设A是B的父类</p><ul><li><code>A a = new B() //打勾，因为B是A子类型</code></li><li><code>A a = new A() //打勾，因为A就是A</code></li><li><code>B b = new A() //打叉，因为A不是B的子类型</code></li></ul><p>而在遍历泛型中数据的时候，我们需要使用一个变量指向泛型数据。相当于进行读取的操作，对应的样例代码为<code>A a = b</code>，其中b为泛型中的数据。因此，为了灵活性，或者为了过编译，b的类型应该为A的子类型或者就是A，所以我们选择了<strong>extends</strong></p><h4 id="2-Lower-Bounded-Wildcards"><a href="#2-Lower-Bounded-Wildcards" class="headerlink" title="2.Lower Bounded Wildcards"></a>2.Lower Bounded Wildcards</h4><p>编写关于修改泛型中数据的方法(增加，删除…)<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line"></span><br><span class="line">    public static void addOne(List&lt;? super Integer&gt; numbers) &#123;</span><br><span class="line">        numbers.add(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;();</span><br><span class="line">        addOne(integerList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于下层限制通配符类型List&lt;? super Integer&gt;同样支持<strong>子类型</strong>，可传入类型参数为Integer或者Integer父类型（如Integer，Number，Object）的泛型  </p><p>选择super的思考：  </p><p>其实与上层限制通配符是一样的道理，这时候需要逆向思维。如在执行add方法的时候，类型参数?是作为消费者的角色，add方法里面应该有类似的代码<code>A a = b</code>。此时，b是我们新增的数据，而a才是泛型数据。同样的道理，为了过审。。。。。。我们选择了super</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>记忆规律:<br>1.”effective java”中提及的PECS，即<strong>producer-extends,consumer-super</strong>，参数化类型作为生产者，则使用extends关键字；参数化类型作为消费者，则使用super关键字<br>2.个人记忆：如果只是想观摩泛型数据，则使用extends，而如果想给泛型数据动动手脚，则使用super</li><li>类型参数的限制图解：<br><img src="http://hlx-blog.oss-cn-beijing.aliyuncs.com/18-5-17/71285439.jpg" alt=""></li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 总结 </tag>
            
            <tag> Bounded  Wildcard Type </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>入门Java:Declared vs Actual Type(声明类型对比实际类型)</title>
      <link href="/2018/05/09/%E5%85%A5%E9%97%A8Java-Declared-vs-Actual-Type-%E7%94%B3%E6%98%8E%E7%B1%BB%E5%9E%8B%E5%AF%B9%E6%AF%94%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/05/09/%E5%85%A5%E9%97%A8Java-Declared-vs-Actual-Type-%E7%94%B3%E6%98%8E%E7%B1%BB%E5%9E%8B%E5%AF%B9%E6%AF%94%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="动态和静态"><a href="#动态和静态" class="headerlink" title="动态和静态"></a>动态和静态</h2><p>动态 == 事物本身的状态是可以随着外部因素而改变。一般指的就是程序的运行期间。例如，子类重写父类的方法，执行方法时，对象的类型决定执行子类或是父类的方法，而对象的类型需要在运行期间才能确定。  </p><p>静态 == 事物本身的状态一直保持不变。一般指的就是程序的编译期间。例如，类的final方法即是静态的，无法被覆盖，对象执行该方法时具有确定性。</p><p>为了更好的区分和识别，可用<code>runtime</code>指代动态，<code>compile-time</code>指代静态。</p><h2 id="声明类型-vs-实际类型"><a href="#声明类型-vs-实际类型" class="headerlink" title="声明类型 vs 实际类型"></a>声明类型 vs 实际类型</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>每一种变量都有两种类型，一个是声明类型，而另一个就是实际类型。  </p><ul><li>Declared Type:<br>as per the program syntax(由语法制作<br>This is static(静态的，即在<strong>compile-time</strong>确定</li><li>Actual Type:<br>as per its creation(由上帝制作？程序员<br>This is dynamic(动态的，即在<strong>runtime</strong>确定</li></ul><p>举个栗子：<br>首先定义以下三个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Plant &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//植物类</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Apple extends Plant&#123;</span><br><span class="line"></span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;i am an apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//苹果类，继承自植物类</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class RedApple extends Apple&#123;</span><br><span class="line"></span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        System.out.println(&quot;i am a redApple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;a redApple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//红苹果类，继承自苹果类</span><br></pre></td></tr></table></figure><p>主函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apple apple = new RedApple();</span><br></pre></td></tr></table></figure></p><p>apple的申明类型为Apple，但是实际类型是RedApple。<br>实际上，<strong>apple变量引用的究竟是Apple对象还是RedApple对象</strong>，编译器是无法知道的，只能等到<code>runtime</code>才可以确定。而<strong>apple变量的申明类型Apple</strong>是确定的，这辈子都不可能更改声明对象。因此，<code>declared type</code>属于<code>static</code>，而<code>actual type</code>属于<code>dynamic</code></p><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><ul><li>声明类型决定了方法的范围<br>尽管apple的实际类型是RedApple，但它是被禁止使用RedApple专属的 show()方法。试想：如果重新分配apple给Apple对象，然后执行RedApple专属方法，那么程序将会瞬间崩溃，而编译器又无法确定对象类型(只能在运行期间确定)。因此，这一规定也合乎情理。</li><li><p>实际类型决定了方法的版本<br>当调用apple的hello()方法(被RedApple overridden)，那么它究竟是执行RedApple版本的方法，还是Apple版本的方法？<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apple apple = new RedApple();</span><br><span class="line">apple.hello();</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i am a redApple</span><br></pre></td></tr></table></figure></li></ul><p>方法的执行是在运行期间，而同时运行期间能够确定变量所引用的对象的类型。这一行为称为<code>Dynamic Dispatch</code>。因此，方法的版本取决于实际类型。</p><h3 id="3-大坑"><a href="#3-大坑" class="headerlink" title="3.大坑"></a>3.大坑</h3><ul><li><p>我们经常分配父类变量给子类对象。如：<code>Apple apple = new RedApple();</code>。而规定中有这么一条：只能分配申明类型为X的变量给申明类型为Y(Y为X的子类型)的变量。因此，如果代码换成如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plant plant = new RedApple();</span><br><span class="line">Apple apple = plant;</span><br></pre></td></tr></table></figure><p>乍一看，好像是正确的，然而抛出警告<code>Incompatible types</code>。不兼容的类型！事实上，背锅的编译器只能假设plant的实际类型就是申明类型Plant，为保护世界和平，不允许这种情况发生，只能依靠声明类型之间的关系进行分配。<br>但是！程序员到底还是上帝一般的存在，通过强制转换，<code>Apple apple = (RedApple) plant;</code>完美进行分配。</p></li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 总结 </tag>
            
            <tag> Declared Type </tag>
            
            <tag> Actual Type </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>入门Java:Reference(引用)</title>
      <link href="/2018/05/02/%E5%85%A5%E9%97%A8Java-Reference/"/>
      <url>/2018/05/02/%E5%85%A5%E9%97%A8Java-Reference/</url>
      <content type="html"><![CDATA[<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul><li>strong reference(强引用)</li><li>weak reference(弱引用)</li><li>soft reference(软引用)</li><li>phantom reference(虚引用/幽灵引用)</li></ul><h2 id="Strong-Reference"><a href="#Strong-Reference" class="headerlink" title="Strong Reference"></a>Strong Reference</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>强引用，坚强的引用，233<br>有多强？强到GC(Garbage Collection)从不敢靠近它<br>如何声明这一最强的引用？(#ﾟДﾟ)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String strongReference = new String(&quot;strong&quot;);</span><br></pre></td></tr></table></figure></p><p>实际上，这是我们平时编程所使用的。任何在内存中具有强引用的对象(不是变量!)都不会被GC处理掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strongReference = null;</span><br></pre></td></tr></table></figure></p><p>执行上句之后，原本的”strong”对象将会缺少有效的引用指向它，则最有可能先被处理掉，如果GC想要的话。<br>过程:<br><img src="http://hlx-blog.oss-cn-beijing.aliyuncs.com/18-5-3/98766925.jpg" alt="强引用过程图"></p><h3 id="2-缺陷"><a href="#2-缺陷" class="headerlink" title="2.缺陷"></a>2.缺陷</h3><p>当强引用过强的时候，也会出现很多麻烦。<br>假设以下场景，GUI编程的时候，经常需要从文件中读取一张非常大的图片资源，每一次读取都将会耗费巨大的时间。<br>因此，可以设计一个图片缓冲区，里面保存着指向内存中图片的引用。但同时，这个引用或者称为强引用将会使得图片定居在内存中，而你就需要进行判断，当图片不再使用时，将它从缓存区中移除，否则<code>memory leak</code>这头怪物随时可能出现。<br>这时，你也就开始你的人工GC之旅。解决方法↓↓↓</p><h2 id="Weak-Reference"><a href="#Weak-Reference" class="headerlink" title="Weak Reference"></a>Weak Reference</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1.概念"></a>1.概念</h3><p>弱引用，多弱？一旦GC饿的时候，分分钟直接抹杀该对象(一个只有弱引用相依为命的对象)，然后从内存中永远消失。<br>测试手册：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date now = new Date();</span><br><span class="line">WeakReference&lt;Date&gt; weakReference = new WeakReference&lt;&gt;(now);</span><br><span class="line">System.out.println(&quot;isNull:&quot;+(weakReference.get()==null));</span><br><span class="line">now = null;</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(&quot;isNull:&quot;+(weakReference.get()==null));</span><br></pre></td></tr></table></figure></p><p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isNull:false</span><br><span class="line">isNull:true</span><br></pre></td></tr></table></figure></p><p>大致的流程图：<br><img src="http://hlx-blog.oss-cn-beijing.aliyuncs.com/18-5-5/31727949.jpg" alt="弱引用流程图"><br>简单的讲解：<br>1.now变量指向Date()对象，weakReference变量指向WeakReference()对象，且WeakReference对象内部保存着Date()对象的引用，可以通过get()方式获取<br>2.now变量指向null,则Date()对象成功入单，只有一个弱引用<br>3.System.gc();提前执行gc过程，并尽可能地促进GC清扫垃圾，实际上可能不进行清扫(还是得看心情，看内存是否够用)<br>参考源码注释:<code>Calling the gc method suggests that Java Virtual Machine expend effort toward recycling unused objects</code><br>4.原先的Date对象离开内存(很有可能)</p><h3 id="2-应用"><a href="#2-应用" class="headerlink" title="2.应用"></a>2.应用</h3><p>一般而言，Weak Reference 需要配合 <code>weakHashMap</code> 服用。<br>weakHashMap？？打开源码：<code>public class WeakHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;</code>，其继承了抽象Map，且实现Map接口。事实上与HashMap的用法一致，可直接当做HashMap。<br>其主要的特点是：</p><ul><li>键值对继承WeakReference</li><li>当key不在使用时，对应的value将自动从map释放，并被gc绝对清除(不用看心情了)  </li></ul><p>上文中提到了图片缓冲区问题，而解决的方法即是通过weakHashMap实现一个高效的image cache。但image不在使用时，可以将其key指向null，则image对象自动从map移除，且被gc清除。利用这一自动清除机制，也就让我们解脱人工gc之旅。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WeakHashMap&lt;String, ImageIcon&gt; imageCache = new WeakHashMap&lt;&gt;();</span><br><span class="line">ImageIcon bigImage = new ImageIcon();</span><br><span class="line">String bigImageName = new String(&quot;apple&quot;);</span><br><span class="line">imageCache.put(bigImageName, bigImage);</span><br><span class="line">System.out.println(&quot;isNull:&quot; + (imageCache.get(&quot;apple&quot;) == null));</span><br><span class="line">// when the image is no longer needed in memory</span><br><span class="line">bigImageName = null;</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(&quot;isNull:&quot; + (imageCache.get(&quot;apple&quot;) == null));</span><br></pre></td></tr></table></figure></p><p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isNull:false</span><br><span class="line">isNull:true</span><br></pre></td></tr></table></figure></p><h2 id="Soft-Reference"><a href="#Soft-Reference" class="headerlink" title="Soft Reference"></a>Soft Reference</h2><h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a>1.概念：</h3><p>软引用，比弱引用强一些，是个软妹子。她会乞求gc实在没有任何选择的情况下，再去清除她的对象，如内存不够用，且唯一可以释放的是她的对象。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date now = new Date();</span><br><span class="line">SoftReference&lt;Date&gt; softReference = new SoftReference&lt;&gt;(now);</span><br><span class="line">now = null;</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(&quot;isNull:&quot;+(softReference.get()==null));</span><br></pre></td></tr></table></figure></p><p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isNull:false</span><br></pre></td></tr></table></figure></p><p>可以看出，软引用的对象并没有立刻被清除。只要jvm不需要内存，那么软引用的对象就会一直存在。</p><h2 id="Phantom-Reference"><a href="#Phantom-Reference" class="headerlink" title="Phantom Reference"></a>Phantom Reference</h2><h3 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1.概念"></a>1.概念</h3><p>幽灵引用？虚幻引用？这是所有引用中名字最装逼的。。。<br>永远无法取回幽灵引用所指向的对象，因此其get()永远返回null<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date now = new Date();</span><br><span class="line">ReferenceQueue&lt;Date&gt; referenceQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Date&gt; phantomReference = new PhantomReference&lt;&gt;(now, referenceQueue);</span><br><span class="line">now = null;</span><br><span class="line">System.out.println(&quot;isNull:&quot;+(phantomReference.get()==null));</span><br></pre></td></tr></table></figure></p><p>Output：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isNull:true</span><br></pre></td></tr></table></figure></p><h3 id="2-应用-1"><a href="#2-应用-1" class="headerlink" title="2.应用"></a>2.应用</h3><p>1.精确控制对象何时从内存中消失。<br>2.避免finalize()两大缺陷：  </p><ul><li>无法保证对象真正被GC清除，并且什么时候被清除</li><li>占用的资源多，降低应用程序的速度  </li></ul><h2 id="引用强度"><a href="#引用强度" class="headerlink" title="引用强度"></a>引用强度</h2><p>Strong Reference&gt;Soft Reference&gt;Weak Reference&gt;Phantom Reference</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 总结 </tag>
            
            <tag> Reference </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>入门Java:Unbounded Wildcard Type(无限制通配符类型)</title>
      <link href="/2018/05/02/%E5%85%A5%E9%97%A8Java-Unbounded-Wildcard-Type-%E6%97%A0%E9%99%90%E5%88%B6%E9%80%9A%E9%85%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/05/02/%E5%85%A5%E9%97%A8Java-Unbounded-Wildcard-Type-%E6%97%A0%E9%99%90%E5%88%B6%E9%80%9A%E9%85%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h2><p>The unbounded wildcard type is specified using the wildcard character (?)<br>无限制通配符类型通过使用通配符字母(?)来明确指定</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p>支持子类型化(subtype)，例如，对于任意具体类型A，List&lt;A&gt;是List&lt;?&gt;的子类型。而对比于泛型，不支持子类型化，List&lt;A&gt;不是List&lt;Object&gt;的子类型。<br>因此，无限制通配符类型的变量可以引用具体类型A的泛型。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;?&gt; test = integerList; //打勾</span><br><span class="line">List&lt;Object&gt; test2 = integerList; //Error:Incompatible</span><br></pre></td></tr></table></figure></li><li><p>不能insert除null以外的元素，由于<code>?</code>是未知类型，不能分配任何除null以外的值<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; test = new ArrayList&lt;String&gt;();</span><br><span class="line">test.add(&quot;a&quot;);</span><br><span class="line">Error:add (capture&lt;?&gt;) in List cannot be applied to (java.lang.String)</span><br></pre></td></tr></table></figure></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="1-定义一个能够通过object类实现的方法"><a href="#1-定义一个能够通过object类实现的方法" class="headerlink" title="1.定义一个能够通过object类实现的方法"></a>1.定义一个能够通过object类实现的方法</h3><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    </span><br><span class="line">    public static void show(List&lt;Object&gt; objectList) &#123;</span><br><span class="line">        for (Object object : objectList) &#123;</span><br><span class="line">            System.out.println(&quot;object-&gt;&gt;&quot;+object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; stringList = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);</span><br><span class="line">        show(stringList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Error：show (java.util.List&lt;java.lang.Object&gt;) in App cannot be applied<br>to (java.util.List&lt;java.lang.String&gt;)<br>由于泛型不支持子类型化，它不能指向List&lt;String&gt;，List&lt;Integer&gt;等等，只能指向List&lt;Object&gt;。而无限制通配符类型支持子类型化，修改show方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void show(List&lt;?&gt; objectList) &#123;</span><br><span class="line">    for (Object object : objectList) &#123;</span><br><span class="line">        System.out.println(&quot;object-&gt;&gt;&quot;+object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object-&gt;&gt;a</span><br><span class="line">object-&gt;&gt;b</span><br><span class="line">object-&gt;&gt;c</span><br></pre></td></tr></table></figure></p><h3 id="2-使用泛型类中不依赖类型参数的方法"><a href="#2-使用泛型类中不依赖类型参数的方法" class="headerlink" title="2.使用泛型类中不依赖类型参数的方法"></a>2.使用泛型类中不依赖类型参数的方法</h3><p>首先定义一个泛型苹果，包括一个颜色域，可以assign任何对象来表示苹果的颜色，例如，<code>Apple&lt;String&gt; apple = new Apple&lt;&gt;(&quot;red&quot;);</code>或者<code>Apple&lt;Color&gt; apple = new Apple&lt;&gt;(Color.BLACK);</code>。其中，包括一个改变颜色的方法，需要依赖于类型参数，另一个显示颜色的方法，不需要依赖于类型参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Apple&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T color;</span><br><span class="line"></span><br><span class="line">    public Apple(T color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void change(T color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着，定义2个通用的方法，1.显示泛型苹果的颜色，2.改变泛型苹果的颜色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line"></span><br><span class="line">    public static void printColor(Apple&lt;?&gt; unboundedApple) &#123;</span><br><span class="line">        unboundedApple.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void changeColor(Apple&lt;?&gt; unboundedApple,String color) &#123;</span><br><span class="line">        unboundedApple.change(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Apple&lt;Color&gt; apple = new Apple&lt;&gt;(Color.BLACK);</span><br><span class="line">        Apple&lt;String&gt; apple2 = new Apple&lt;&gt;(&quot;blue&quot;);</span><br><span class="line">        printColor(apple);</span><br><span class="line">        printColor(apple2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译时，changeColor()抛出异常<code>change(capture&lt;?&gt;) in Apple cannot be appliedto (java.lang.String)</code>这是由于unboundedApple是未知类型所引发的。注释changeColor()后再次运行。<br>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.awt.Color[r=0,g=0,b=0]</span><br><span class="line">blue</span><br></pre></td></tr></table></figure></p><p>因此，可以使用<code>Unbounded Wildcard Type</code>指向具体的泛型类，并调用该泛型类的任何不依赖于类型参数的方法</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 总结 </tag>
            
            <tag> Unbounded Wildcard Type </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>入门Java:Raw Type(原生态类型)</title>
      <link href="/2018/05/01/%E5%85%A5%E9%97%A8Java-Row-Types-%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/05/01/%E5%85%A5%E9%97%A8Java-Row-Types-%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h2><p>A raw type is the name of a generic class or interface without any type of arguements<br>生的类型？还没煮熟？原生态类型是没有任何类型参数的泛型类或泛型接口的名字</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List rawList = new ArrayList();</span><br></pre></td></tr></table></figure><ul><li>List = 没有类型参数的泛型接口</li><li>ArrayList = 没有类型参数的泛型类</li><li>两者都是原生态类型</li><li>注意：非泛型的类或泛型接口都不是原生态类型</li></ul><h2 id="存在的意义"><a href="#存在的意义" class="headerlink" title="存在的意义"></a>存在的意义</h2><ul><li>JAVA 1.5之前，没有泛型机制，只能编写原生态类型</li><li>为了向后兼容(Backward Compatibility)，或者是移植兼容性(Migration Compatibility)，现在仍然支持原生态类型。例如，可以assign一个类型参数给原生态类型</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="1-类文字-class-literal"><a href="#1-类文字-class-literal" class="headerlink" title="1.类文字(class literal)"></a>1.类文字(class literal)</h3><p>类文字中必须使用原生态类型，规范不允许使用参数化类型。就是一个规定！例如，不能使用<code>List&lt;String&gt;.class</code>，而必须用<code>List.class</code>。可能就是为了简便吧。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class test = List&lt;String&gt;.class;</span><br><span class="line">ERROR：</span><br><span class="line">    Cannot select from parameterized type</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class test = List.class; //打勾</span><br></pre></td></tr></table></figure><h3 id="2-实例-instance-操作符"><a href="#2-实例-instance-操作符" class="headerlink" title="2.实例(instance)操作符"></a>2.实例(instance)操作符</h3><p>禁止在参数化类型(parameterized type)上使用instanceof。这也是一个规定！<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List test = new ArrayList();</span><br><span class="line">if (test instanceof ArrayList&lt;String&gt;) &#123;</span><br><span class="line">    System.out.println(&quot;bingo~&quot;);</span><br><span class="line">&#125;</span><br><span class="line">ERROR:</span><br><span class="line">    Illegal generic type for instanceof</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List test = new ArrayList();</span><br><span class="line">if (test instanceof ArrayList) &#123;</span><br><span class="line">    System.out.println(&quot;bingo~&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//打勾</span><br></pre></td></tr></table></figure><p>两者都是因为<strong>泛型信息在运行期间被erasure</strong>这一事实(来源自《Effective Java》)。既然被erasure，那么<code>List&lt;String&gt;.class</code> == <code>List.class</code>，为啥是非法的？？有待考量，TODO:为啥非法。博主认为就应该只是一个规定的问题。  </p><p>较为合理的解释：type parameters 仅仅生存在编译期间，由于reflection本质上是一个运行期间的东西，无法识别type parameters</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="1-安全性"><a href="#1-安全性" class="headerlink" title="1.安全性"></a>1.安全性</h3><p>原生类型没有类型参数，导致编译器缺少足够的信息，绕过泛型检查，会引起<code>unchecked error</code>。例如，对原生态类型操作时，容易引发<code>ClassCastException</code><br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line"></span><br><span class="line">    public void add(List list, Object object) &#123;</span><br><span class="line">        list.add(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;();</span><br><span class="line">        new App().add(integerList,new Date());</span><br><span class="line">        Integer element = integerList.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>add(List list, Object object)</code>能够通过编译，由于原生态类型没有<code>parameterized type</code>，因此，任何object都能够添加，但会引发编译警告<code>Unchecked call to &#39;add(E)&#39; as a member of raw type &#39;java.util.List&#39;</code>。<br>当尝试从<code>integerList</code>获取<code>element</code>时，将会付出忽略警告的代价，抛出<code>java.lang.ClassCastException: java.util.Date cannot be cast to java.lang.Integer</code></p><h3 id="2-阅读性"><a href="#2-阅读性" class="headerlink" title="2.阅读性"></a>2.阅读性</h3><p>原生态类型没有<code>parameterized type</code>，无法直接从表面上看出这个类型所包含的具体信息。而对于泛型类，如<code>List&lt;String&gt;</code>，可以简单的认为这是字符串列表。阅读性的丧失，将会导致代码的维护难度大大提高。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 总结 </tag>
            
            <tag> Raw Type </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo Admin Deploy扩展教程</title>
      <link href="/2018/05/01/Hexo-Admin-Deploy%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/05/01/Hexo-Admin-Deploy%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/jaredly/hexo-admin/issues/94" target="_blank" rel="noopener">hexo-admin/issues</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于Windows的某种原因，依据网站的大部分教程，均会抛出<code>deploy Error: spawn UNKNOWN</code>异常。而GitHub上issues给出了相关解决方案，现在总结一下具体的过程(填坑</p><h2 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h2><ul><li><p>打开站点配置文件(<code>\xxxx.github.io\_config.yml</code>)，在<code>admin</code>中加入<code>deployCommand: &#39;sh hexo-deploy.sh&#39;</code>。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">admin:</span><br><span class="line">  username: 看不见</span><br><span class="line">  password_hash: 看不见</span><br><span class="line">  secret: 看不见</span><br><span class="line">  deployCommand: &apos;sh hexo-deploy.sh&apos;</span><br></pre></td></tr></table></figure></li><li><p>在根目录中(<code>\xxxx.github.io\</code>)新建<code>hexo-deploy.sh</code>文件，内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li><li><p>打开deploy.js(<code>\xxxx.github.io\node_modules\hexo-admin\deploy.js</code>)，将<code>var proc = spawn(command, [message], {detached: true});</code>更改为<code>var proc = spawn((process.platform === &quot;win32&quot; ? &quot;hexo.cmd&quot; : &quot;hexo&quot;), [&#39;d&#39;, &#39;-g&#39;]);</code><br>更改完后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function (command, message, done) &#123;</span><br><span class="line">  done = once(done);</span><br><span class="line">  var proc = spawn((process.platform === &quot;win32&quot; ? &quot;hexo.cmd&quot; : &quot;hexo&quot;), [&apos;d&apos;, &apos;-g&apos;]);</span><br><span class="line">  var stdout = &apos;&apos;;</span><br><span class="line">  var stderr = &apos;&apos;;</span><br><span class="line">  proc.stdout.on(&apos;data&apos;, function(data)&#123;stdout += data.toString()&#125;)</span><br><span class="line">  proc.stderr.on(&apos;data&apos;, function(data)&#123;stderr += data.toString()&#125;)</span><br><span class="line">  proc.on(&apos;error&apos;, function(err) &#123;</span><br><span class="line">    done(err, &#123;stdout: stdout, stderr: stderr&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  proc.on(&apos;close&apos;, function () &#123;</span><br><span class="line">    done(null, &#123;stdout: stdout, stderr: stderr&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="http://hlx-blog.oss-cn-beijing.aliyuncs.com/18-5-1/52473923.jpg" alt="效果图"></p>]]></content>
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NexT 底部logo栏更改教程</title>
      <link href="/2018/05/01/%E5%BA%95%E9%83%A8logo%E6%A0%8F%E6%9B%B4%E6%94%B9%E6%95%99%E7%A8%8B/"/>
      <url>/2018/05/01/%E5%BA%95%E9%83%A8logo%E6%A0%8F%E6%9B%B4%E6%94%B9%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>1.从 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">图标库</a> 中挑选一款图标。<br>2.修改主题配置文件(<code>\xxxx.github.io\themes\next\_config.yml</code>)中footer.icon：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  icon: user</span><br></pre></td></tr></table></figure><p>将icon值改为图标的名称。</p>]]></content>
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NexT Live2D模块安装教程</title>
      <link href="/2018/05/01/Live2D-%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2018/05/01/Live2D-%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><p><code>npm install --save hexo-helper-live2d</code></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在站点配置文件(<code>\xxxx.github.io\_config.yml</code>)的尾部，加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-koharu # 模型的名称</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: false # 手机是否显示，考虑手机的显示问题，可以选择false</span><br></pre></td></tr></table></figure></p><h2 id="安装模型"><a href="#安装模型" class="headerlink" title="安装模型"></a>安装模型</h2><p>从 <a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">模型库</a> 中找到一款喜欢的，然后<code>npm install live2d-widget-model-模型名称</code>进行安装，修改配置文件。<br>例如：看上初音未来的模型(<code>miku</code>)，则通过<code>npm install live2d-widget-model-miku</code>安装模型。然后修改站点配置文件中的model：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model:</span><br><span class="line">  use: live2d-widget-model-koharu</span><br></pre></td></tr></table></figure></p><p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model:</span><br><span class="line">  use: live2d-widget-model-miku</span><br></pre></td></tr></table></figure></p><p>重启博客，就会发现右下角出现一只神奇的东西(斜眼笑.jpg)。</p>]]></content>
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Live 2D </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title> GitHub Pages 腾讯云CDN加速教程</title>
      <link href="/2018/04/30/GitHub-Pages-%E8%85%BE%E8%AE%AF%E4%BA%91CDN%E5%8A%A0%E9%80%9F%E6%95%99%E7%A8%8B/"/>
      <url>/2018/04/30/GitHub-Pages-%E8%85%BE%E8%AE%AF%E4%BA%91CDN%E5%8A%A0%E9%80%9F%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>基于GitHub Pages搭建的博客是存储在GitHub服务器上，而GitHub Pages共用一台服务器，且服务器是在外国。因此，打开博客 = ppt演示。目前一种主流的方式是通过CDN提高网页的响应速度。</p><p>网络上有很多关于腾讯云CDN加速教程，但是不够详细，博主也因此折腾半天。现在，总结一下目前腾讯云CDN加速的具体流程。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>GitHub Pages 地址解析到个人域名(可以参照之前<a href="http://www.inmyai.com/2018/04/29/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/" target="_blank" rel="noopener">博客搭建指南</a>中的<a href="http://localhost:4000/admin/#/posts/cjgm8pvcs00004k7kbmzh5pwj" target="_blank" rel="noopener">基础教程</a>)</li></ul><h2 id="开始食用"><a href="#开始食用" class="headerlink" title="开始食用"></a>开始食用</h2><h3 id="1-开通腾讯云CDN服务，添加域名。"><a href="#1-开通腾讯云CDN服务，添加域名。" class="headerlink" title="1.开通腾讯云CDN服务，添加域名。"></a>1.开通<a href="https://console.cloud.tencent.com/cdn" target="_blank" rel="noopener">腾讯云CDN服务</a>，添加域名。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">域名:输入你自己的个人域名，wwww.xxxx.com</span><br><span class="line">源站设置:输入你GitHub Pages的ip地址，具体如下</span><br><span class="line">其他保持默认</span><br></pre></td></tr></table></figure><p>例如，我的GitHub Pages:hlxing.github.io，打开命令行，输入<code>ping hlxing.github.io</code></p><p><img src="http://hlx-blog.oss-cn-beijing.aliyuncs.com/18-4-30/37722924.jpg" alt="示例"><br>源站设置为: <code>185.199.110.153</code></p><h3 id="2-等待部署，然后获取CNAME，效果图："><a href="#2-等待部署，然后获取CNAME，效果图：" class="headerlink" title="2.等待部署，然后获取CNAME，效果图："></a>2.等待部署，然后获取CNAME，效果图：</h3><p><img src="http://hlx-blog.oss-cn-beijing.aliyuncs.com/18-4-30/78284969.jpg" alt="效果图"></p><p>CNAME为：<code>www.xxxx.com.cdn.dnsv1.com</code></p><h3 id="3-进入域名管理，点击解析，添加4条记录。"><a href="#3-进入域名管理，点击解析，添加4条记录。" class="headerlink" title="3.进入域名管理，点击解析，添加4条记录。"></a>3.进入<a href="https://console.cloud.tencent.com/domain" target="_blank" rel="noopener">域名管理</a>，点击解析，添加4条记录。</h3><ul><li><p>第一条(可选)：  </p><p><img src="http://hlx-blog.oss-cn-beijing.aliyuncs.com/18-4-30/47077302.jpg" alt="@"></p><p>主机记录选择 <code>@</code> ,映射xxxx.com<br>记录类型选择 <code>CNAME</code><br>线路类型选择 <code>国内</code>，只有国内进行访问时生效<br>记录值输入刚刚从CDN获取的<code>CNAME</code></p></li><li><p>第二条(必选):</p><p><img src="http://hlx-blog.oss-cn-beijing.aliyuncs.com/18-4-30/84970049.jpg" alt="www"></p><p>主机记录选择 <code>www</code> ,映射<a href="http://www.xxxx.com" target="_blank" rel="noopener">www.xxxx.com</a><br>记录类型选择 <code>CNAME</code><br>线路类型选择 <code>国内</code>，只有国内进行访问时生效<br>记录值输入刚刚从CDN获取的<code>CNAME</code></p></li><li><p>第三条(可选):</p><p><img src="http://hlx-blog.oss-cn-beijing.aliyuncs.com/18-4-30/87422341.jpg" alt="@国外"></p><p>主机记录选择 <code>@</code> ,映射xxxx.com<br>记录类型选择 <code>CNAME</code><br>线路类型选择 <code>国外</code>，只有国外进行访问时生效<br>记录值输入 自己的<code>GitHub Pages地址</code></p></li><li><p>第四条(必选):</p><p><img src="http://hlx-blog.oss-cn-beijing.aliyuncs.com/18-4-30/80226340.jpg" alt="www国外"></p><p>主机记录选择 <code>www</code> ,映射<a href="http://www.xxxx.com" target="_blank" rel="noopener">www.xxxx.com</a><br>记录类型选择 <code>CNAME</code><br>线路类型选择 <code>国外</code>，只有国外进行访问时生效<br>记录值输入 自己的<code>GitHub Pages地址</code></p></li><li><p>关于分国外国内：</p><p>GitHub Pages服务器在外国，用国内的CDN等于没有，且国外访问GitHub Pages是十分流畅的。</p></li></ul><h3 id="4-CDN验证"><a href="#4-CDN验证" class="headerlink" title="4.CDN验证"></a>4.CDN验证</h3><ul><li>打开命令行，输入 <code>ping xxxx.com</code> 或者 <code>www.xxxx.com</code>，如果出现的IP地址不是你GitHub Pages的ip地址，则CDN加速成功。如果没有，则可能是CDN还没有完成部署，或者域名解析还没完成(一般需要几分钟)。</li></ul><p><img src="http://hlx-blog.oss-cn-beijing.aliyuncs.com/18-4-30/76553225.jpg" alt="CDN验证"></p><h2 id="食用效果"><a href="#食用效果" class="headerlink" title="食用效果"></a>食用效果</h2><p>打开<a href="http://ping.chinaz.com" target="_blank" rel="noopener">站长之家的Ping检测</a>，输入<code>xxxx.com</code>，或<code>www.xxxx.com</code>，或<code>xxxx.github.io</code>。</p><p>原本是一只褐色的公鸡(尚未开启CDN加速):</p><p><img src="http://hlx-blog.oss-cn-beijing.aliyuncs.com/18-4-30/5166014.jpg" alt="褐色公鸡"></p><p>然后被绿了(开启CDN加速):</p><p><img src="http://hlx-blog.oss-cn-beijing.aliyuncs.com/18-4-30/2001038.jpg" alt="绿色公鸡"></p><p>可见，效果极佳！</p><ul><li>备注：检测<code>xxxx.github.io</code>时发现还是一只褐色公鸡？？但实际上，它会发生重定向(F12查询)，且重定向后的请求的Remote Address均是CDN加速所用的服务器，因此CDN效果依然存在。</li></ul>]]></content>
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客搭建指南</title>
      <link href="/2018/04/29/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
      <url>/2018/04/29/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自己写一个博客系统吧？不存在的。<br>推荐一个快速搭建博客的方法，采用Hexo + GitHub Pages进行搭建，简单实用，而且不需要自己购买9块9包月的服务器。</p><h2 id="食用方法"><a href="#食用方法" class="headerlink" title="食用方法"></a>食用方法</h2><ul><li><a href="http://www.lovebxm.com/2017/05/30/buildBlog/" target="_blank" rel="noopener">基础教程</a>(大概需要20分钟，完成博客的基础模块，出自<strong>白小明</strong>大佬)</li><li><a href="https://www.jianshu.com/p/5973c05d7100" target="_blank" rel="noopener">进阶教程</a>(大概需要几个小时，扩展博客的功能，出自<strong>代码咖啡</strong>大佬)</li></ul><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li>进阶教程中的搜索功能添加出现问题的话(我就是一个)，可以采用另一种方法：<br><a href="https://zty.js.org/post/2016/07/08/hexo-localsearch.html" target="_blank" rel="noopener">本地站内搜索</a>(出自<strong>Zetao Yang</strong>大佬)</li><li>更多扩展功能请自行百度</li></ul><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>Live2D 模块安装教程(右下角那只宠物就是Live2D的产物</li><li>底部logo栏更改教程</li><li>Hexo-Admin后台管理中Deploy功能的正确打开方式(Windows 环境下)</li><li>腾讯云CDN加速教程</li></ul>]]></content>
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hello blog</title>
      <link href="/2018/04/27/hello-blog/"/>
      <url>/2018/04/27/hello-blog/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">quu..__</span><br><span class="line"> $$$b  `---.__</span><br><span class="line">  &quot;$$b        `--.                          ___.---uuudP</span><br><span class="line">   `$$b           `.__.------.__     __.---&apos;      $$$$&quot;              .</span><br><span class="line">     &quot;$b          -&apos;            `-.-&apos;            $$$&quot;              .&apos;|</span><br><span class="line">       &quot;.                                       d$&quot;             _.&apos;  |</span><br><span class="line">         `.   /                              ...&quot;             .&apos;     |</span><br><span class="line">           `./                           ..::-&apos;            _.&apos;       |</span><br><span class="line">            /                         .:::-&apos;            .-&apos;         .&apos;</span><br><span class="line">           :                          ::&apos;&apos;\          _.&apos;            |</span><br><span class="line">          .&apos; .-.             .-.           `.      .&apos;               |</span><br><span class="line">          : /&apos;$$|           .@&quot;$\           `.   .&apos;              _.-&apos;</span><br><span class="line">         .&apos;|$u$$|          |$$,$$|           |  &lt;            _.-&apos;</span><br><span class="line">         | `:$$:&apos;          :$$$$$:           `.  `.       .-&apos;</span><br><span class="line">         :                  `&quot;--&apos;             |    `-.     \</span><br><span class="line">        :##.       ==             .###.       `.      `.    `\</span><br><span class="line">        |##:                      :###:        |        &gt;     &gt;</span><br><span class="line">        |#&apos;     `..&apos;`..&apos;          `###&apos;        x:      /     /</span><br><span class="line">         \                                   xXX|     /    ./</span><br><span class="line">          \                                xXXX&apos;|    /   ./</span><br><span class="line">          /`-.                                  `.  /   /</span><br><span class="line">         :    `-  ...........,                   | /  .&apos;</span><br><span class="line">         |         ``:::::::&apos;       .            |&lt;    `.</span><br><span class="line">         |             ```          |           x| \ `.:``.</span><br><span class="line">         |                         .&apos;    /&apos;   xXX|  `:`M`M&apos;:.</span><br><span class="line">         |    |                    ;    /:&apos; xXXX&apos;|  -&apos;MMMMM:&apos;</span><br><span class="line">         `.  .&apos;                   :    /:&apos;       |-&apos;MMMM.-&apos;</span><br><span class="line">          |  |                   .&apos;   /&apos;        .&apos;MMM.-&apos;</span><br><span class="line">          `&apos;`&apos;                   :  ,&apos;          |MMM&lt;</span><br><span class="line">            |                     `&apos;            |tbap\</span><br><span class="line">             \                                  :MM.-&apos;</span><br><span class="line">              \                 |              .&apos;&apos;</span><br><span class="line">               \.               `.            /</span><br><span class="line">                /     .:::::::.. :           /</span><br><span class="line">               |     .:::::::::::`.         /</span><br><span class="line">               |   .:::------------\       /</span><br><span class="line">              /   .&apos;&apos;               &gt;::&apos;  /</span><br><span class="line">              `&apos;,:                 :    .&apos;</span><br><span class="line">                                   `:.:&apos;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
